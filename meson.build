project('postgresql',
  ['c'],
  version: '15devel',
  license: 'PostgreSQL',
  meson_version: '>=0.54',
  default_options: [
    'warning_level=2',
    'b_pie=true',
    'b_pch=false',
    'buildtype=release',
    'c_std=c99',
  ]
)



###############################################################
# Basic prep
###############################################################

fs = import('fs')
windows = import('windows')

thread_dep = dependency('threads')

cpu_family = host_machine.cpu_family()


# It's very easy to get into confusing states when the source directory
# contains an in-place build. E.g. the wrong pg_config.h will be used. So just
# refuse to build in that case.
if fs.exists(meson.current_source_dir() / 'src' / 'include' / 'pg_config.h')
  error('''
****
Non-clean source code directory detected.

To build with meson the source tree may not have an in-place, ./configure
style, build configured. Use a separate check out for meson based builds, or
run make distclean in the source tree.

You can have both meson and ./configure style builds for the same source tree
by building out-of-source / VPATH with configure as well.
****
''')
endif



###############################################################
# Version and other metadata
###############################################################

pg_version = meson.project_version()

if pg_version.endswith('devel')
  pg_version_arr = [pg_version.split('devel')[0], '0']
elif pg_version.contains('beta')
  pg_version_arr = pg_version.split('beta')
elif pg_version.contains('rc')
  pg_version_arr = pg_version.split('rc')
else
  pg_version_arr = pg_version.split('.')
endif

pg_version_major = pg_version_arr[0].to_int()
pg_version_minor = pg_version_arr[1].to_int()

cc = meson.get_compiler('c')

cdata = configuration_data()


cdata.set_quoted('PACKAGE_NAME', 'PostgreSQL')
cdata.set_quoted('PACKAGE_BUGREPORT', 'pgsql-bugs@lists.postgresql.org')
cdata.set_quoted('PACKAGE_URL', 'https://www.postgresql.org/')

cdata.set_quoted('PG_VERSION', pg_version)
cdata.set_quoted('PG_VERSION_STR', 'PostgreSQL @0@ on @1@, compiled by @2@-@3@'.format(
  pg_version, target_machine.cpu_family(), cc.get_id(), cc.version()))
cdata.set_quoted('PG_MAJORVERSION', pg_version_major.to_string())
cdata.set('PG_MAJORVERSION_NUM', pg_version_major)
cdata.set_quoted('PG_MINORVERSION', pg_version_minor.to_string())
cdata.set('PG_MINORVERSION_NUM', pg_version_minor)
cdata.set('PG_VERSION_NUM', (pg_version_major*10000)+pg_version_minor)
cdata.set_quoted('CONFIGURE_ARGS', '')



###############################################################
# Search paths
#
# NB: Arguments added globally (via the below, or CFLAGS etc) are not taken
# into account for configuration-time checks (so they are more
# isolated). Flags that have to be taken into account for configure checks
# have to be explicitly specified in configure tests.
###############################################################

g_inc = []
g_c_args = []
g_l_args = []

if host_machine.system() == 'darwin'
  # XXX, should this be required?
  xcrun = find_program('xcrun', native: true, required: true)

  sysroot = run_command(xcrun, '--show-sdk-path', check: true).stdout().strip()
  message('sysroot is >@0@<'.format(sysroot))

  g_c_args += ['-isysroot', sysroot]
  g_l_args += ['-isysroot', sysroot]
endif

if host_machine.system() == 'linux' or host_machine.system() == 'cygwin'
  g_c_args += '-D_GNU_SOURCE'
endif

g_c_inc = []

g_c_inc += include_directories(get_option('extra_include_dirs'))
g_c_lib = get_option('extra_lib_dirs')

add_project_arguments(g_c_args, language: ['c', 'cpp'])
add_project_link_arguments(g_l_args, language: ['c', 'cpp'])



###############################################################
# Program paths
###############################################################

# External programs
perl = find_program(get_option('PERL'), required: true)
flex = find_program(get_option('FLEX'), native: true)
bison = find_program(get_option('BISON'), native: true, version: '>= 1.875')
sed = find_program(get_option('SED'), 'sed', native: true)
prove = find_program(get_option('PROVE'))
tar = find_program(get_option('TAR'), native: true)
gzip = find_program(get_option('GZIP'), native: true)
touch = find_program('touch', native: true)

# Internal programs
find_meson = find_program('src/tools/find_meson', native: true)
testwrap = find_program('src/tools/testwrap', native: true)
relpath = find_program('src/tools/relpath.py', native: true)

bisonflags = []
if bison.found()
  bison_version_c = run_command(bison, '--version', check: true)
  # bison version string helpfully is something like
  # >>bison (GNU bison) 3.8.1<<
  bison_version = bison_version_c.stdout().split(' ')[3].split('\n')[0]
  if bison_version.version_compare('>=3.0')
    bisonflags += ['-Wno-deprecated']
  endif
endif


wget = find_program('wget', required: false, native: true)
wget_flags = ['-O', '@OUTPUT0@', '--no-use-server-timestamps']


###############################################################
# Path to meson (for tests etc)
###############################################################

# FIXME: this should really be part of meson, see
# https://github.com/mesonbuild/meson/issues/8511
meson_binpath_r = run_command(find_meson, check: true)

if meson_binpath_r.returncode() != 0 or meson_binpath_r.stdout() == ''
  error('huh, could not run find_meson.\nerrcode: @0@\nstdout: @1@\nstderr: @2@'.format(
    meson_binpath_r.returncode(),
    meson_binpath_r.stdout(),
    meson_binpath_r.stderr()))
endif

meson_binpath_s = meson_binpath_r.stdout().split('\n')
meson_binpath_len = meson_binpath_s.length()

if meson_binpath_len < 1
  error('unexpected introspect line @0@'.format(meson_binpath_r.stdout()))
endif

i = 0
meson_binpath = ''
meson_args = []
foreach e : meson_binpath_s
  if i == 0
    meson_binpath = e
  else
    meson_args += e
  endif
  i += 1
endforeach

meson_bin = find_program(meson_binpath, native: true)



###############################################################
# Option Handling
###############################################################

cdata.set('USE_ASSERT_CHECKING', get_option('cassert'))

cdata.set('BLCKSZ', 8192, description: '''
 Size of a disk block --- this also limits the size of a tuple.  You
 can set it bigger if you need bigger tuples (although TOAST should
 reduce the need to have large tuples, since fields can be spread
 across multiple tuples).

 BLCKSZ must be a power of 2.  The maximum possible value of BLCKSZ
 is currently 2^15 (32768).  This is determined by the 15-bit widths
 of the lp_off and lp_len fields in ItemIdData (see
 include/storage/itemid.h).

 Changing BLCKSZ requires an initdb.
''')

cdata.set('XLOG_BLCKSZ', 8192)
cdata.set('RELSEG_SIZE', 131072)
cdata.set('DEF_PGPORT', 5432)
cdata.set_quoted('DEF_PGPORT_STR', '5432')
cdata.set_quoted('PG_KRB_SRVNAM', 'postgres')



###############################################################
# Library: GSSAPI
###############################################################

gssapiopt = get_option('gssapi')
if not gssapiopt.disabled()
  gssapi = dependency('krb5-gssapi', required: gssapiopt)

  if gssapi.found() and \
    cc.check_header('gssapi/gssapi.h', args: g_c_args, dependencies: gssapi, required: gssapiopt)

    if not cc.has_function('gss_init_sec_context', args: g_c_args, dependencies: gssapi)
      error('''could not find function 'gss_init_sec_context' required for GSSAPI''')
    endif
    cdata.set('ENABLE_GSS', 1)
  endif

else
  gssapi = dependency('', required : false)
endif



###############################################################
# Library: ldap
###############################################################

ldapopt = get_option('ldap')
if not ldapopt.disabled()

  if host_machine.system() == 'windows'
    ldap = cc.find_library('wldap32')
    ldap_r = ldap
  else
    ldap = dependency('ldap', required: false)

    # Before 2.5 openldap didn't have a pkg-config file..
    if ldap.found()
      ldap_r = ldap
    else
      ldap = cc.find_library('ldap', required: ldapopt)
      ldap_r = cc.find_library('ldap_r', required: ldapopt)

      # Use ldap_r for FE if available, else assume ldap is thread-safe.
      # On some platforms ldap_r fails to link without PTHREAD_LIBS.
      if ldap.found() and not ldap_r.found()
        ldap_r = ldap
      endif
    endif

    if ldap.found() and cc.has_function('ldap_initialize', args: g_c_args, dependencies: [ldap, thread_dep])
      cdata.set('HAVE_LDAP_INITIALIZE', 1)
    endif
  endif

  if ldap.found()
    cdata.set('USE_LDAP', 1)
  endif

else
  ldap = dependency('', required : false)
  ldap_r = ldap
endif



###############################################################
# Library: LLVM
###############################################################

llvmopt = get_option('llvm')
if not llvmopt.disabled()
  add_languages('cpp', required : true, native: false)
  llvm = dependency('llvm', version : '>=3.9', method: 'config-tool', required: llvmopt)

  if llvm.found()

    cdata.set('USE_LLVM', 1)

    cpp = meson.get_compiler('cpp')

    llvm_binpath = llvm.get_variable(configtool: 'bindir')

    ccache = find_program('ccache', required: false)
    clang = find_program(llvm_binpath / 'clang', required: true)
    llvm_lto = find_program(llvm_binpath / 'llvm-lto', required: true)

    # FIXME: the includes hardcoded here suck
    llvm_irgen_args = [
      '-c', '-o', '@OUTPUT@', '@INPUT@',
      '-flto=thin', '-emit-llvm',
      '-MD', '-MQ', '@OUTPUT@', '-MF', '@DEPFILE@',
      '-I', '@SOURCE_ROOT@/src/include',
      '-I', '@BUILD_ROOT@/src/include',
      '-I', '@BUILD_ROOT@/src/backend/utils/misc',
      '-I', '@CURRENT_SOURCE_DIR@',
      '-O2',
      '-Wno-ignored-attributes',
      '-Wno-empty-body',
    ]

    if ccache.found()
      llvm_irgen_command = ccache
      llvm_irgen_args = [clang.path()] + llvm_irgen_args
    else
      llvm_irgen_command = clang
    endif

    llvm_irgen_kw = {
      'command': [llvm_irgen_command] + llvm_irgen_args,
      'depfile': '@BASENAME@.c.bc.d',
    }

    irlink = find_program('src/tools/irlink', native: true)

    llvm_irlink_kw = {
      'command':[
        irlink,
        '@SOURCE_ROOT@',
        '@BUILD_ROOT@',
        llvm_lto,
        '-o', '@OUTPUT0@',
        '@PRIVATE_DIR@',
        '@INPUT@',
      ],
      'install': true,
      'install_dir': get_option('libdir'),
    }

  endif
else
  llvm = dependency('', required: false)
endif



###############################################################
# Library: icu
###############################################################

if not get_option('icu').disabled()
  icu = dependency('icu-uc', required: get_option('icu').enabled())
  icu_i18n = dependency('icu-i18n', required: get_option('icu').enabled())

  if icu.found()
    cdata.set('USE_ICU', 1)
  endif

else
  icu = dependency('', required : false)
  icu_i18n = dependency('', required : false)
endif



###############################################################
# Library: libxml
###############################################################

libxmlopt = get_option('libxml')
if not libxmlopt.disabled()
  libxml = dependency('libxml-2.0', required: libxmlopt, version: '>= 2.6.23')

  if libxml.found()
    cdata.set('USE_LIBXML', 1)
  endif
else
  libxml = dependency('', required : false)
endif



###############################################################
# Library: libxslt
###############################################################

libxsltopt = get_option('libxslt')
if not libxsltopt.disabled()
  libxslt = dependency('libxslt', required: libxsltopt)

  if libxslt.found()
    cdata.set('USE_LIBXSLT', 1)
  endif
else
  libxslt = dependency('', required : false)
endif



###############################################################
# Library: lz4
###############################################################

lz4opt = get_option('lz4')
if not lz4opt.disabled()
  lz4 = dependency('liblz4', required: lz4opt)

  if lz4.found()
    cdata.set('USE_LZ4', 1)
    cdata.set('HAVE_LIBLZ4', 1)
  endif

else
  lz4 = dependency('', required : false)
endif



###############################################################
# Library: Perl (for plperl)
###############################################################

perlopt = get_option('perl')
perl_dep = dependency('', required: false)

if perlopt.disabled()
  perl_may_work = false
else
  perl_may_work = true

  # First verify that perl has the necessary dependencies installed
  perl_mods = run_command(
    [perl,
     '-MConfig', '-MOpcode', '-MExtUtils::Embed', '-MExtUtils::ParseXS',
     '-e', ''],
    check: false)
  if perl_mods.returncode() != 0
    perl_may_work = false
    perl_msg = 'perl installation does not have the required modules'
  endif

  # Then inquire perl about its configuration
  if perl_may_work
    # FIXME: include copy-edited comments from perl.m4
    perl_conf_cmd = [perl, '-MConfig', '-e', 'print $Config{$ARGV[0]}']
    perlversion = run_command(perl_conf_cmd, 'api_versionstring', check: true).stdout()
    archlibexp = run_command(perl_conf_cmd, 'archlibexp', check: true).stdout()
    privlibexp = run_command(perl_conf_cmd, 'privlibexp', check: true).stdout()
    useshrplib = run_command(perl_conf_cmd, 'useshrplib', check: true).stdout()
    libperl = run_command(perl_conf_cmd, 'libperl', check: true).stdout()

    perl_inc_dir = '@0@/CORE'.format(archlibexp)

    perl_ccflags = []

    if useshrplib != 'true'
      perl_may_work = false
      perl_msg = 'need a shared perl'
    endif
  endif

  # XXX: should we only add directories that exist? Seems a bit annoying with
  # macos' sysroot stuff...
  #
  # NB: For unknown reasons msys' python doesn't see these paths, despite gcc
  # et al seeing them. So we can't use include_directories(), as that checks
  # file existence.
  if perl_may_work
    perl_ccflags += ['-I@0@'.format(perl_inc_dir)]
    if host_machine.system() == 'darwin'
      perl_ccflags += ['-iwithsysroot', perl_inc_dir]
    endif
  endif

  # check required headers are present
  if perl_may_work and not \
    cc.has_header('perl.h', args: g_c_args + perl_ccflags, required: false)
    perl_may_work = false
    perl_msg = 'missing perl.h'
  endif

  # Find perl library. This is made more complicated by the fact that the name
  # Config.pm returns isn't directly usable (sometimes lib needs to be chopped
  # off)
  if perl_may_work
    foreach p : ['perl', 'libperl', libperl, libperl.strip('lib'), fs.stem(libperl), fs.stem(libperl).strip('lib')]
      perl_dep_int = cc.find_library(p,
        dirs: ['@0@/CORE'.format(archlibexp)],
        required: false)
      if perl_dep_int.found()
        break
      endif
    endforeach

    if not perl_dep_int.found()
      perl_may_work = false
      perl_msg = 'missing libperl'
    endif
  endif

  if perl_may_work
    perl_ccflags_r = run_command(perl_conf_cmd, 'ccflags', check: true).stdout()
    message('CCFLAGS recommended by Perl: @0@'.format(perl_ccflags_r))

    foreach flag : perl_ccflags_r.split(' ')
      if flag.startswith('-D') and \
        (not flag.startswith('-D_') or flag == '_USE_32BIT_TIME_T')
        perl_ccflags += flag
      endif
    endforeach

    if host_machine.system() == 'windows'
      perl_ccflags += ['-DPLPERL_HAVE_UID_GID']
    endif

    message('CCFLAGS for embedding perl: @0@'.format(' '.join(perl_ccflags)))

    # perl.m4 sayeth:
    #
    # We are after Embed's ldopts, but without the subset mentioned in
    # Config's ccdlflags;
    #
    # FIXME: andres sayeth: But why?

    ldopts = run_command(perl, '-MExtUtils::Embed', '-e', 'ldopts', check: true).stdout().strip()
    ccdlflags = run_command(perl_conf_cmd, 'ccdlflags', check: true).stdout().strip()

    ccdlflags_dict = {}

    foreach ccdlflag : ccdlflags.split(' ')
      ccdlflags_dict += {ccdlflag: 1}
    endforeach

    perl_ldopts = []
    foreach ldopt : ldopts.split(' ')
      if ldopt == ''
        continue
      elif ccdlflags_dict.has_key(ldopt)
        continue
      # strawberry perl unhelpfully has that in ldopts
      elif ldopt == '-s'
        continue
      endif

      perl_ldopts += ldopt.strip('"')
    endforeach

    # FIXME: check if windows handling is necessary

    message('LDFLAGS for embedding perl: "@0@" (ccdlflags: "@1@", ldopts: "@2@")'.format(
      ' '.join(perl_ldopts), ccdlflags, ldopts))

    if perl_dep_int.found()
      perl_dep = declare_dependency(
        compile_args: perl_ccflags,
        link_args: perl_ldopts,
        version: perlversion,
      )
    endif
  endif # perl_may_work

  if not perl_may_work
    if perlopt.enabled()
      error('dependency perl failed: @0@'.format(perl_msg))
    else
      message('disabling optional dependency perl: @0@'.format(perl_msg))
    endif
  endif
endif



###############################################################
# Library: Python (for plpython)
###############################################################

pyopt = get_option('python')
if not pyopt.disabled()
  pm = import('python')
  python3_inst = pm.find_installation(required: pyopt.enabled())
  python3 = python3_inst.dependency(embed: true, required: pyopt.enabled())
else
  python3 = dependency('', required: false)
endif



###############################################################
# Library: Readline
#
# FIXME: editline support
###############################################################

if not get_option('readline').disabled()
  readline = dependency('readline', required: false)
  if not readline.found()
    readline = cc.find_library('readline',
      required: get_option('readline').enabled())
  endif

  if readline.found()
    cdata.set('HAVE_LIBREADLINE', 1)

    if cc.has_header('readline/history.h', args: g_c_args, dependencies: [readline], required: false)
      history_h = 'readline/history.h'
      cdata.set('HAVE_READLINE_HISTORY_H', 1)
      cdata.set('HAVE_READLINE_H', false)
    elif cc.has_header('history.h', args: g_c_args, dependencies: [readline], required: false)
      history_h = 'history.h'
      cdata.set('HAVE_READLINE_HISTORY_H', false)
      cdata.set('HAVE_HISTORY_H', 1)
    else
      error('''readline header not found
If you have readline already installed, see see meson-log/meson-log.txt for details on the
failure.  It is possible the compiler isn't looking in the proper directory.
Use -Dreadline=false to disable readline support.''')
    endif

    if cc.has_header('readline/readline.h', args: g_c_args, dependencies: [readline], required: false)
      readline_h = 'readline/readline.h'
      cdata.set('HAVE_READLINE_READLINE_H', 1)
    elif cc.has_header('readline.h', args: g_c_args, dependencies: [readline], required: false)
      readline_h = 'readline.h'
      cdata.set('HAVE_READLINE_H', 1)
    else
      error('''readline header not found
If you have readline already installed, see see meson-log/meson-log.txt for details on the
failure.  It is possible the compiler isn't looking in the proper directory.
Use -Dreadline=false to disable readline support.''')
    endif

    check_funcs = [
      'rl_completion_matches',
      'rl_filename_completion_function',
      'rl_reset_screen_size',
      'append_history',
      'history_truncate_file',
    ]

    foreach func : check_funcs
      cdata.set('HAVE_'+func.to_upper(),
        cc.has_function(func, args: g_c_args, dependencies: [readline]) ? 1 : false)
    endforeach

    check_vars = [
      'rl_completion_append_character',
      'rl_completion_suppress_quote',
      'rl_filename_quote_characters',
      'rl_filename_quoting_function',
    ]

    foreach var : check_vars
      cdata.set('HAVE_'+var.to_upper(),
        cc.has_header_symbol(readline_h, var, args: g_c_args, dependencies: [readline]) ? 1 : false)
    endforeach
  endif
else
  readline = dependency('', required : false)
endif



###############################################################
# Library: selinux
###############################################################

selinux = dependency('', required : false)
selinuxopt = get_option('selinux')
if not selinuxopt.disabled()
  selinux = dependency('libselinux', required: selinuxopt, version: '>= 2.1.10')
endif
cdata.set('HAVE_LIBSELINUX',
  selinux.found() ? 1 : false)



###############################################################
# Library: systemd
###############################################################

systemd = dependency('', required : false)
systemdopt = get_option('systemd')
if meson.version().version_compare('>=0.59')
  systemdopt = systemdopt.disable_auto_if(host_machine.system() != 'linux')
endif
if not systemdopt.disabled()
  systemd = dependency('libsystemd', required: systemdopt)
endif
cdata.set('USE_SYSTEMD',
  systemd.found() ? 1 : false)



###############################################################
# Library: SSL
###############################################################

if get_option('ssl') == 'openssl'

  # Try to find openssl via pkg-config et al, if that doesn't work, look for
  # the library names that we know about.

  # via pkg-config et al
  ssl = dependency('openssl', required: false)

  # via library + headers
  if not ssl.found()
    ssl_lib = cc.find_library('ssl',
      dirs: g_c_lib,
      header_include_directories: g_c_inc,
      has_headers: ['openssl/ssl.h', 'openssl/err.h'])
    crypto_lib = cc.find_library('crypto',
      dirs: g_c_lib,
      header_include_directories: g_c_inc)
    ssl_int = [ssl_lib, crypto_lib]

    ssl = declare_dependency(dependencies: ssl_int,
                             include_directories: g_c_inc)
  else
    cc.has_header('openssl/ssl.h', args: g_c_args, dependencies: ssl, required: true)
    cc.has_header('openssl/err.h', args: g_c_args, dependencies: ssl, required: true)

    ssl_int = [ssl]
  endif

  cdata.set_quoted('WITH_SSL', get_option('ssl'))

  check_funcs = [
    ['CRYPTO_new_ex_data', {'required': true}],
    ['SSL_new', {'required': true}],

    # Function introduced in OpenSSL 1.0.2.
    ['X509_get_signature_nid'],

    # Functions introduced in OpenSSL 1.1.0. We used to check for
    # OPENSSL_VERSION_NUMBER, but that didn't work with 1.1.0, because LibreSSL
    # defines OPENSSL_VERSION_NUMBER to claim version 2.0.0, even though it
    # doesn't have these OpenSSL 1.1.0 functions. So check for individual
    # functions.
    ['OPENSSL_init_ssl'],
    ['BIO_get_data'],
    ['BIO_meth_new'],
    ['ASN1_STRING_get0_data'],
    ['HMAC_CTX_new'],
    ['HMAC_CTX_free'],

    # OpenSSL versions before 1.1.0 required setting callback functions, for
    # thread-safety. In 1.1.0, it's no longer required, and CRYPTO_lock()
    # function was removed.
    ['CRYPTO_lock'],
  ]

  foreach c : check_funcs
    func = c.get(0)
    val = cc.has_function(func, args: g_c_args, dependencies: ssl_int)
    if not val and c.get(1, {}).get('required', false)
      error('openssl function @0@ is required'.format(func))
    endif
    cdata.set('HAVE_'+func.to_upper(), val ? 1 : false)
  endforeach

  cdata.set('USE_OPENSSL', 1,
            description: 'Define to 1 to build with OpenSSL support. (-Dssl=openssl)')

  cdata.set('OPENSSL_API_COMPAT', 0x10001000,
            description: 'Define to the OpenSSL API version in use. This avoids deprecation warnings from newer OpenSSL versions.')
else
  ssl = dependency('', required : false)
endif



###############################################################
# Library: uuid
###############################################################

uuidopt = get_option('uuid')
if uuidopt != 'none'
  uuidname = uuidopt.to_upper()
  if uuidopt == 'e2fs'
    uuid = dependency('uuid', required: true)
    uuidfunc = 'uuid_generate'
    uuidheader = 'uuid/uuid.h'
  elif uuidopt == 'bsd'
    # libc should have uuid function
    uuid = declare_dependency()
    uuidfunc = 'uuid_to_string'
    uuidheader = 'uuid.h'
  elif uuidopt == 'ossp'
    uuid = dependency('ossp-uuid', required: true)
    uuidfunc = 'uuid_export'
    uuidheader = 'ossp/uuid.h'
  else
    error('huh')
  endif

  if not cc.has_header_symbol(uuidheader, uuidfunc, dependencies: uuid)
    error('uuid library @0@ missing required function @1@'.format(uuidopt, uuidfunc))
  endif
  cdata.set('HAVE_@0@'.format(uuidheader.underscorify().to_upper()), 1)

  cdata.set('HAVE_UUID_@0@'.format(uuidname), 1,
           description: 'Define to 1 if you have @0@ UUID support.'.format(uuidname))
else
  uuid = dependency('', required : false)
endif



###############################################################
# Library: zlib
###############################################################

zlibopt = get_option('zlib')
zlib = dependency('', required : false)
if not zlibopt.disabled()
  zlib_t = dependency('zlib', required: zlibopt)

  if zlib_t.type_name() == 'internal'
    # if fallback was used, we don't need to test if headers are present (they
    # aren't built yet, so we can't test)
    zlib = zlib_t
  elif not zlib_t.found()
    warning('did not find zlib')
  elif not cc.has_header('zlib.h', args: g_c_args, dependencies: [zlib_t], required: zlibopt.enabled())
    warning('zlib header not found')
  elif not cc.has_type('z_streamp', args: g_c_args, dependencies: [zlib_t], prefix: '#include <zlib.h>')
    if zlibopt.enabled()
      error('zlib version is too old')
    else
      warning('zlib version is too old')
    endif
  else
    zlib = zlib_t
  endif

  if zlib.found()
    cdata.set('HAVE_LIBZ', 1)
  endif
endif



###############################################################
# Compiler tests
###############################################################

sizeof_long = cc.sizeof('long', args: g_c_args)
cdata.set('SIZEOF_LONG', sizeof_long)
if sizeof_long == 8
  cdata.set('HAVE_LONG_INT_64', 1)
  cdata.set('PG_INT64_TYPE', 'long int')
  cdata.set_quoted('INT64_MODIFIER', 'l')
elif sizeof_long == 4 and cc.sizeof('long long', args: g_c_args) == 8
  cdata.set('HAVE_LONG_LONG_INT_64', 1)
  cdata.set('PG_INT64_TYPE', 'long long int')
  cdata.set_quoted('INT64_MODIFIER', 'll')
else
  error('do not know how to get a 64bit int')
endif


cdata.set('MAXIMUM_ALIGNOF', 8)
cdata.set('ALIGNOF_SHORT', cc.alignment('short', args: g_c_args))
cdata.set('ALIGNOF_INT', cc.alignment('int', args: g_c_args))
cdata.set('ALIGNOF_LONG', cc.alignment('long', args: g_c_args))
cdata.set('ALIGNOF_DOUBLE', cc.alignment('double', args: g_c_args))
cdata.set('SIZEOF_VOID_P', cc.sizeof('void *', args: g_c_args))
cdata.set('SIZEOF_SIZE_T', cc.sizeof('size_t', args: g_c_args))

# Check if the C compiler knows computed gotos (gcc extension, also
# available in at least clang).  If so, define HAVE_COMPUTED_GOTO.
#
# Checking whether computed gotos are supported syntax-wise ought to
# be enough, as the syntax is otherwise illegal.
if cc.compiles('''
    static inline int foo(void)
    {
      void *labeladdrs[] = {&&my_label};
      goto *labeladdrs[0];
      my_label:
      return 1;
    }''',
    args: g_c_args)
  cdata.set('HAVE_COMPUTED_GOTO', 1)
endif


# XXX: for now just assume that compiler knows __func__ - it's C99 after all.
cdata.set('HAVE_FUNCNAME__FUNC', 1)

# Check if the C compiler understands _Static_assert(),
# and define HAVE__STATIC_ASSERT if so.
#
# We actually check the syntax ({ _Static_assert(...) }), because we need
# gcc-style compound expressions to be able to wrap the thing into macros.
if cc.compiles('''
    int main(int arg, char **argv)
    {
        ({ _Static_assert(1, "foo"); })
    }
    ''',
    args: g_c_args)
  cdata.set('HAVE__STATIC_ASSERT', 1)
endif

# We use <stdbool.h> if we have it and it declares type bool as having
# size 1.  Otherwise, c.h will fall back to declaring bool as unsigned char.
if cc.has_type('_Bool', args: g_c_args) \
  and cc.has_type('bool', prefix: '#include <stdbool.h>', args: g_c_args) \
  and cc.sizeof('bool', prefix: '#include <stdbool.h>', args: g_c_args) == 1
  cdata.set('HAVE__BOOL', 1)
  cdata.set('PG_USE_STDBOOL', 1)
endif


printf_attributes = ['gnu_printf', '__syslog__', 'printf']
testsrc = 'extern void pgac_write(int ignore, const char *fmt,...) __attribute__((format(@0@, 2,3)));'
foreach a : printf_attributes
  if cc.compiles(testsrc.format(a), args: g_c_args + ['-Werror'], name: 'format ' + a)
    cdata.set('PG_PRINTF_ATTRIBUTE', a)
    break
  endif
endforeach

if cc.has_function_attribute('visibility:default') and \
  cc.has_function_attribute('visibility:hidden')
  cdata.set('HAVE_VISIBILITY_ATTRIBUTE', 1)
endif


if cc.has_function('__builtin_unreachable', args: g_c_args)
  cdata.set('HAVE__BUILTIN_UNREACHABLE', 1)
endif

if cc.has_function('__builtin_constant_p', args: g_c_args)
  cdata.set('HAVE__BUILTIN_CONSTANT_P', 1)

  if host_machine.cpu_family() == 'ppc' or host_machine.cpu_family() == 'ppc64'
    # Check if compiler accepts "i"(x) when __builtin_constant_p(x).
    if cc.compiles('''
      static inline int
      addi(int ra, int si)
      {
          int res = 0;
          if (__builtin_constant_p(si))
              __asm__ __volatile__(
                  " addi %0,%1,%2\n" : "=r"(res) : "b"(ra), "i"(si));
          return res;
      }
      int test_adds(int x) { return addi(3, x) + addi(x, 5); }
      ''',
      args: g_c_args)
      cdata.set('HAVE_I_CONSTRAINT__BUILTIN_CONSTANT_P', 1)
    endif
  endif
endif



# XXX: The configure.ac check for __cpuid() is broken, we don't copy that
# here. To prevent problems due to two detection methods working, stop
# checking after one.
if cc.links('''
    #include <cpuid.h>
    int main(int arg, char **argv)
    {
        unsigned int exx[4] = {0, 0, 0, 0};
        __get_cpuid(1, &exx[0], &exx[1], &exx[2], &exx[3]);
    }
    ''', name: '__get_cpuid',
    args: g_c_args)
  cdata.set('HAVE__GET_CPUID', 1)
elif cc.links('''
    #include <intrin.h>
    int main(int arg, char **argv)
    {
        unsigned int exx[4] = {0, 0, 0, 0};
        __cpuid(exx, 1);
    }
    ''', name: '__cpuid',
    args: g_c_args)
  cdata.set('HAVE__CPUID', 1)
endif



###############################################################
# Compiler flags
###############################################################

common_functional_flags = [
  # Disable strict-aliasing rules; needed for gcc 3.3+
  '-fno-strict-aliasing',
  # Disable optimizations that assume no overflow; needed for gcc 4.3+
  '-fwrapv',
  '-fexcess-precision=standard'
]

add_project_arguments(cc.get_supported_arguments(common_functional_flags), language: 'c')

vectorize_cflags = cc.get_supported_arguments(['-ftree-vectorize'])
unroll_loops_cflags = cc.get_supported_arguments(['-funroll-loops'])


common_warning_flags = [
  '-Wmissing-prototypes',
  '-Wpointer-arith',
  '-Werror=vla',
  '-Wendif-labels',
  '-Wmissing-format-attribute',
  '-Wimplicit-fallthrough=3',
  '-Wcast-function-type',
  '-Wformat-security',
]

add_project_arguments(cc.get_supported_arguments(common_warning_flags), language: 'c')

if llvm.found()
  add_project_arguments(cpp.get_supported_arguments(common_warning_flags), language: 'cpp')
endif

# A few places with imported code get a pass on -Wdeclaration-after-statement, remember
# the result for them
if cc.has_argument('-Wdeclaration-after-statement')
  add_project_arguments('-Wdeclaration-after-statement', language: 'c')
  using_declaration_after_statement_warning = true
else
  using_declaration_after_statement_warning = false
endif


# We want to suppress a few unhelpful warnings - but gcc won't
# complain about unrecognized -Wno-foo switches, so we have to test
# for the positive form and if that works, add the negative form

negative_warning_flags = [
  'unused-command-line-argument',
  'format-truncation',
  'stringop-truncation',

  # FIXME: from andres's local config
  'clobbered',
  'missing-field-initializers',
  'sign-compare',
  'unused-parameter',
]

foreach w : negative_warning_flags
  if cc.has_argument('-W'+w)
    add_project_arguments('-Wno-'+w, language: 'c')
  endif

  if llvm.found() and cpp.has_argument('-W'+w)
    add_project_arguments('-Wno-'+w, language: 'cpp')
  endif
endforeach


# From Project.pm
if cc.get_id() == 'msvc'
  add_project_arguments('/wd4018', '/wd4244', '/wd4273', '/wd4102', '/wd4090', '/wd4267',
    language: 'c')
  add_project_arguments('/DWIN32', '/DWINDOWS', '/D__WINDOWS__', '/D__WIN32__',
    '/DWIN32_STACK_RLIMIT=4194304', '/D_CRT_SECURE_NO_DEPRECATE', '/D_CRT_NONSTDC_NO_DEPRECATE',
        language: 'c')
endif



###############################################################
# Atomics
###############################################################

# FIXME
cdata.set('HAVE_SPINLOCKS', 1)

if get_option('atomics')
  # FIXME
  cdata.set('HAVE_ATOMICS', 1)

  atomic_checks = [
    {'name': 'HAVE_GCC__SYNC_CHAR_TAS',
     'desc': '__sync_lock_test_and_set(char)',
     'test': '''
char lock = 0;
__sync_lock_test_and_set(&lock, 1);
__sync_lock_release(&lock);'''},

    {'name': 'HAVE_GCC__SYNC_INT32_TAS',
     'desc': '__sync_lock_test_and_set(int32)',
     'test': '''
int lock = 0;
__sync_lock_test_and_set(&lock, 1);
__sync_lock_release(&lock);'''},

    {'name': 'HAVE_GCC__SYNC_INT32_CAS',
     'desc': '__sync_val_compare_and_swap(int32)',
     'test': '''
int val = 0;
__sync_val_compare_and_swap(&val, 0, 37);'''},

# FIXME: int64 reference
    {'name': 'HAVE_GCC__SYNC_INT64_CAS',
     'desc': '__sync_val_compare_and_swap(int64)',
     'test': '''
long val = 0;
__sync_val_compare_and_swap(&val, 0, 37);'''},

    {'name': 'HAVE_GCC__ATOMIC_INT32_CAS',
     'desc': ' __atomic_compare_exchange_n(int32)',
     'test': '''
int val = 0;
int expect = 0;
__atomic_compare_exchange_n(&val, &expect, 37, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);'''},

# FIXME: int64 reference
    {'name': 'HAVE_GCC__ATOMIC_INT64_CAS',
     'desc': ' __atomic_compare_exchange_n(int64)',
     'test': '''
long val = 0;
int expect = 0;
__atomic_compare_exchange_n(&val, &expect, 37, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);'''},
  ]

  foreach check : atomic_checks
    test = '''
int main(void)
{
@0@
}'''.format(check['test'])

    cdata.set(check['name'],
      cc.links(test, name: check['desc'], args: g_c_args))
  endforeach

endif



###############################################################
# CRC
###############################################################

have_optimized_crc = false
cflags_crc = []
if cpu_family == 'x86' or cpu_family == 'x86_64'

  if cc.get_id() == 'msvc'
    cdata.set('USE_SSE42_CRC32C', false)
    cdata.set('USE_SSE42_CRC32C_WITH_RUNTIME_CHECK', 1)
    have_optimized_crc = true
  else

    prog = '''
#include <nmmintrin.h>

int main(void)
{
    unsigned int crc = 0;
    crc = _mm_crc32_u8(crc, 0);
    crc = _mm_crc32_u32(crc, 0);
    /* return computed value, to prevent the above being optimized away */
    return crc == 0;
}
'''

    if cc.links(prog, name: '_mm_crc32_u8 and _mm_crc32_u32 without -msse4.2', args: g_c_args)
      cdata.set('USE_SSE42_CRC32C', 1)
      have_optimized_crc = true
    elif cc.links(prog, name: '_mm_crc32_u8 and _mm_crc32_u32 with -msse4.2', args: g_c_args + ['-msse4.2'])
      cflags_crc += '-msse4.2'
      cdata.set('USE_SSE42_CRC32C', false)
      cdata.set('USE_SSE42_CRC32C_WITH_RUNTIME_CHECK', 1)
      have_optimized_crc = true
    endif

  endif

elif cpu_family == 'arm' or cpu_family == 'aarch64'

  prog = '''
#include <arm_acle.h>

int main(void)
{
    unsigned int crc = 0;
    crc = __crc32cb(crc, 0);
    crc = __crc32ch(crc, 0);
    crc = __crc32cw(crc, 0);
    crc = __crc32cd(crc, 0);

    /* return computed value, to prevent the above being optimized away */
    return crc == 0;
}
'''

  if cc.links(prog, name: '__crc32cb, __crc32ch, __crc32cw, and __crc32cd without -march=armv8-a+crc',
      args: g_c_args)
    cdata.set('USE_ARMV8_CRC32C', true)
    have_optimized_crc = true
  elif cc.links(prog, name: '__crc32cb, __crc32ch, __crc32cw, and __crc32cd with -march=armv8-a+crc',
      args: g_c_args + ['-march=armv8-a+crc'])
    cflags_crc += '-march=armv8-a+crc'
    cdata.set('USE_ARMV8_CRC32C', false)
    cdata.set('USE_ARMV8_CRC32C_WITH_RUNTIME_CHECK', 1)
    have_optimized_crc = true
  endif
endif

if not have_optimized_crc
  cdata.set('USE_SLICING_BY_8_CRC32C', 1)
endif



###############################################################
# Library / OS tests
###############################################################

header_checks = [
  ['atomic.h'],
  ['stdbool.h'],
  ['copyfile.h'],
  ['execinfo.h'],
  ['getopt.h'],
  ['ifaddrs.h'],
  ['langinfo.h'],
  ['mbarrier.h'],
  ['poll.h'],
  ['sys/epoll.h'],
  ['sys/event.h'],
  ['sys/ipc.h'],
  ['sys/prctl.h'],
  ['sys/procctl.h'],
  ['sys/pstat.h'],
  ['sys/resource.h'],
  ['sys/select.h'],
  ['sys/sem.h'],
  ['sys/shm.h'],
  ['sys/sockio.h'],
  ['sys/tas.h'],
  ['sys/uio.h'],
  ['sys/un.h'],
  ['termios.h'],
  ['ucred.h'],
  # FIXME: openbsd workaround
  ['sys/ucred.h'],
  ['wctype.h'],
  ['netinet/tcp.h'],
  ['net/if.h'],
  ['crtdefs.h'],
]

foreach c : header_checks
  varname = 'HAVE_'+c.get(0).underscorify().to_upper()

  # Emulate autoconf behaviour of not-found->undef, found->1
  found = cc.has_header(c.get(0), include_directories: g_inc, args: g_c_args)
  cdata.set(varname, found ? 1 : false,
            description: 'Define to 1 if you have the <@0@> header file.'.format(c))
endforeach



decl_checks = [
  ['F_FULLFSYNC', 'fcntl.h'],
  ['RTLD_GLOBAL', 'dlfcn.h'],
  ['RTLD_NOW', 'dlfcn.h'],
  ['fdatasync', 'unistd.h'],
  ['posix_fadvise', 'fcntl.h'],
  ['sigwait', 'signal.h'],
  ['strlcat', 'string.h'],
  ['strlcpy', 'string.h'],
  ['strnlen', 'string.h'],
  ['strsignal', 'string.h'],
  ['strtoll', 'stdlib.h'], ['strtoull', 'stdlib.h'], # strto[u]ll may exist but not be declared
]

# Need to check for function declarations for these functions, because
# checking for library symbols wouldn't handle deployment target
# restrictions on macOS
decl_checks += [
  ['preadv', 'sys/uio.h'],
  ['pwritev', 'sys/uio.h'],
]

foreach c : decl_checks
  varname = 'HAVE_DECL_'+c.get(0).underscorify().to_upper()

  found = cc.has_header_symbol(c.get(1), c.get(0), args: g_c_args, kwargs: c.get(2, {}))
  cdata.set10(varname, found, description:
'''Define to 1 if you have the declaration of `@0@\', and to 0 if you
  don't.'''.format(c))
endforeach



# XXX: this is borked, HAVE_SYS_UCRED_H not defined
if cc.has_type('struct cmsgcred',
    include_directories: g_inc,
    args: g_c_args + ['@0@'.format(cdata.get('HAVE_SYS_UCRED_H')) == 'false' ? '-DHAVE_SYS_UCRED_H' : ''],
    prefix: '''
#include <sys/socket.h>
#include <sys/param.h>
#ifdef HAVE_SYS_UCRED_H
#include <sys/ucred.h>
#endif''')
  cdata.set('HAVE_STRUCT_CMSGCRED', 1)
else
  cdata.set('HAVE_STRUCT_CMSGCRED', false)
endif

if cc.has_function('getopt', args: g_c_args) and \
   cc.has_function('getopt_long', args: g_c_args) and \
   cc.has_type('struct option', args: g_c_args, prefix: '#include <getopt.h>')
  cdata.set('HAVE_GETOPT', 1)
  cdata.set('HAVE_GETOPT_LONG', 1)
  cdata.set('HAVE_STRUCT_OPTION', 1)
else
  warning('not yet implemented')
endif


foreach c : ['opterr', 'optreset']
  varname = 'HAVE_INT_'+c.underscorify().to_upper()

  if cc.links('''
#include <unistd.h>
int main(void)
{
    extern int @0@;
    @0@ = 1;
}
'''.format(c), name: c, args: g_c_args)
    cdata.set(varname, 1)
  else
    cdata.set(varname, false)
  endif
endforeach


if cc.has_type('struct sockaddr_storage', args: g_c_args, prefix: '''
#include <sys/types.h>
#include <sys/socket.h>''')
  cdata.set('HAVE_STRUCT_SOCKADDR_STORAGE', 1)
endif

if cc.has_member('struct sockaddr_storage', 'ss_family', args: g_c_args,
  prefix: '''#include <sys/types.h>
#include <sys/socket.h>''')
  cdata.set('HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY', 1)
endif

if cc.has_member('struct sockaddr_storage', '__ss_family', args: g_c_args,
  prefix: '''
#include <sys/types.h>
#include <sys/socket.h>''')
  cdata.set('HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY', 1)
endif

if cc.has_type('struct sockaddr_un', args: g_c_args, prefix: '''
#include <sys/types.h>
#include <sys/un.h>''')
  cdata.set('HAVE_STRUCT_SOCKADDR_UN', 1)
endif

if cc.has_type('struct addrinfo', args: g_c_args, prefix: '''
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
''')
  cdata.set('HAVE_STRUCT_ADDRINFO', 1)
endif

if host_machine.system() == 'windows'
  cdata.set('HAVE_STRUCT_SOCKADDR_STORAGE', 1)
  cdata.set('HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY', 1)
endif

if cc.has_type('struct sockaddr_in6', args: g_c_args, prefix: '''
#include <netinet/in.h>''')
  cdata.set('HAVE_IPV6', 1)
endif


if cc.has_member('struct tm', 'tm_zone', args: g_c_args, prefix: '''
#include <sys/types.h>
#include <time.h>
''')
  cdata.set('HAVE_STRUCT_TM_TM_ZONE', 1)
endif

if cc.compiles('''
#include <time.h>
extern int foo(void);
int foo(void)
{
    return timezone / 60;
}
''', name: 'Check if the global variable `timezone\' exists', args: g_c_args,)
  cdata.set('HAVE_INT_TIMEZONE', 1)
else
  cdata.set('HAVE_INT_TIMEZONE', false)
endif

# FIXME: sys/ipc.h, sys/sem.h includes were conditional
if cc.has_type('union semun', args: g_c_args, prefix: '''
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
''')
  cdata.set('HAVE_UNION_SEMUN', 1)
endif

if cc.compiles('''
#include <string.h>
int main(void)
{
  char buf[100];
  switch (strerror_r(1, buf, sizeof(buf)))
  { case 0: break; default: break; }
}''', args: g_c_args)
  cdata.set('STRERROR_R_INT', 1)
else
  cdata.set('STRERROR_R_INT', false)
endif

# FIXME
cdata.set('pg_restrict', '__restrict')

# FIXME
if host_machine.system() == 'windows'
  cdata.set('ACCEPT_TYPE_ARG1', 'unsigned int')
  cdata.set('ACCEPT_TYPE_ARG2', 'struct sockaddr *')
  cdata.set('ACCEPT_TYPE_ARG3', 'int')
  cdata.set('ACCEPT_TYPE_RETURN', 'unsigned int PASCAL')
else
  cdata.set('ACCEPT_TYPE_ARG1', 'int')
  cdata.set('ACCEPT_TYPE_ARG2', 'struct sockaddr')
  cdata.set('ACCEPT_TYPE_ARG3', 'socklen_t')
  cdata.set('ACCEPT_TYPE_RETURN', 'int')
endif

cdata.set('HAVE_STRUCT_ADDRINFO', 1)


cdata.set('MEMSET_LOOP_LIMIT', 1024)


if cc.links('''
#include <machine/vmparam.h>
#include <sys/exec.h>

int main(void)
{
    PS_STRINGS->ps_nargvstr = 1;
    PS_STRINGS->ps_argvstr = "foo";
}
''',
  name: 'PS_STRINGS', args: g_c_args)
  cdata.set('HAVE_PS_STRINGS', 1)
else
  cdata.set('HAVE_PS_STRINGS', false)
endif


m_dep = cc.find_library('m', required : false)

# Most libraries are included only if they demonstrably provide a function we
# need, but libm is an exception: always include it, because there are too
# many compilers that play cute optimization games that will break probes for
# standard functions such as pow().
os_deps = [m_dep]

rt_dep = cc.find_library('rt', required : false)

dl_dep = cc.find_library('dl', required : false)

util_dep = cc.find_library('util', required : false)
posix4_dep = cc.find_library('posix4', required : false)

getopt_dep = cc.find_library('getopt', required : false)
gnugetopt_dep = cc.find_library('gnugetopt', required : false)

execinfo_dep = cc.find_library('execinfo', required : false)

func_checks = [
  ['_configthreadlocale'],
  ['backtrace_symbols', {'dependencies': [execinfo_dep]}],
  ['clock_gettime', {'dependencies': [rt_dep, posix4_dep]}],
  ['copyfile'],
  ['dlopen', {'dependencies': [dl_dep]}],
  ['explicit_bzero'],
  ['fdatasync', {'dependencies': [rt_dep, posix4_dep]}],
  ['fls'],
  ['getaddrinfo'],
  ['gethostbyname_r', {'dependencies': [thread_dep]}],
  ['getifaddrs'],
  ['getopt', {'dependencies': [getopt_dep, gnugetopt_dep]}],
  ['getopt_long',{'dependencies': [getopt_dep, gnugetopt_dep]}],
  ['getpeereid'],
  ['getpeerucred'],
  ['getpwuid_r', {'dependencies': [thread_dep]}],
  ['getrlimit'],
  ['getrusage'],
  ['gettimeofday'], # XXX: This seems to be in the autoconf case
  ['inet_aton'],
  ['kqueue'],
  ['link'],
  ['mbstowcs_l'],
  ['memset_s'],
  ['mkdtemp'],
  ['poll'],
  ['posix_fadvise'],
  ['posix_fallocate'],
  ['ppoll'],
  ['pread'],
  ['pstat'],
  ['pthread_is_threaded_np'],
  ['pwrite'],
  ['random'],
  ['readlink'],
  ['readv'],
  ['setenv'], # FIXME: windows handling
  ['setproctitle', {'dependencies': [util_dep]}],
  ['setproctitle_fast'],
  ['setsid'],
  ['shm_open', {'dependencies': [rt_dep]}],
  ['shm_unlink', {'dependencies': [rt_dep]}],
  ['srandom'],
  ['strchrnul'],
  ['strerror_r', {'dependencies': [thread_dep]}],
  ['strlcat'],
  ['strlcpy'],
  ['strnlen'],
  ['strsignal'],
  ['strtof'], # strsignal is checked separately
  ['strtoll'], ['__strtoll'], ['strtoq'],
  ['strtoull'], ['__strtoull'], ['strtouq'],
  ['symlink'],
  ['sync_file_range'],
  ['syncfs'],
  ['unsetenv'],
  ['uselocale'],
  ['wcstombs_l'],
  ['writev'],
]

foreach c : func_checks
  func = c.get(0)
  kwargs = c.get(1, {})
  deps = kwargs.get('dependencies', [])

  varname = 'HAVE_'+func.underscorify().to_upper()

  found = cc.has_function(func, args: g_c_args,
                          kwargs: kwargs + {'dependencies': []})

  if not found
    foreach dep : deps
      if not dep.found()
        continue
      endif
      found = cc.has_function(func, args: g_c_args,
                              kwargs: kwargs + {'dependencies': [dep]})
      if found
        os_deps += dep
        break
      endif
    endforeach
  endif

  # Emulate autoconf behaviour of not-found->undef, found->1
  cdata.set(varname, found  ? 1 : false,
            description: 'Define to 1 if you have the `@0@\' function.'.format(c))
endforeach





if host_machine.system() == 'linux' or host_machine.system() == 'freebsd'
  dlsuffix = '.so'
elif host_machine.system() == 'darwin'
  dlsuffix = '.dylib'
elif host_machine.system() == 'windows'
  dlsuffix = '.dll'
else
  error('not yet')
endif

cdata.set_quoted('DLSUFFIX', dlsuffix)

if host_machine.system() == 'windows'
   cdata.set('USE_WIN32_SEMAPHORES', 1)
   cdata.set('USE_WIN32_SHARED_MEMORY', 1)
elif host_machine.system() == 'darwin'
   cdata.set('USE_SYSV_SEMAPHORES', 1)
   cdata.set('USE_SYSV_SHARED_MEMORY', 1)
else
   cdata.set('USE_UNNAMED_POSIX_SEMAPHORES', 1)
   cdata.set('USE_SYSV_SHARED_MEMORY', 1)
endif


if host_machine.system() == 'windows'
  cdata.set('HAVE_IPV6', 1)
  cdata.set('HAVE_SYMLINK', 1)
  cdata.set('WIN32_STACK_RLIMIT', 4194304)
  cdata.set('HAVE__CONFIGTHREADLOCALE', 1)
endif

if cc.get_id() == 'msvc'
  add_project_link_arguments(
    '/fixed:no',
    '/dynamicbase',
    '/nxcompat',
    language : ['c', 'cpp'],
  )
endif

if host_machine.system() == 'windows'
  os_deps += cc.find_library('ws2_32', required: true)
endif



###############################################################
# Threading
###############################################################

# Probably not worth implementing other cases anymore
cdata.set('ENABLE_THREAD_SAFETY', 1)

if thread_dep.found()
  if cc.has_function('pthread_is_threaded_np', args: g_c_args, dependencies: [thread_dep])
    cdata.set('HAVE_PTHREAD_IS_THREADED_NP', 1)
  endif
  if cc.has_function('pthread_barrier_wait', args: g_c_args, dependencies: [thread_dep])
    cdata.set('HAVE_PTHREAD_BARRIER_WAIT', 1)
  endif
endif



###############################################################
# Build
###############################################################

# Collect a number of lists of things while recursing through the source
# tree. Later steps then can use those.

test_deps = []
backend_targets = []


# List of tap tests we later generate test() invocations for. The main
# reason for doing it that way instead of having test() invocations
# everywhere is that they end up being too large. A second benefit is
# that it'd make it easier to generate data for another runner.
tap_tests = []
isolation_tests = []
regress_tests = []


# Default options for targets

default_target_args = {
  'implicit_include_directories': false,
  'install': true,
}

default_lib_args = default_target_args + {
  'name_prefix': 'lib',
}

internal_lib_args = default_lib_args + {
  'build_by_default': false,
  'install': false,
}

default_mod_args = default_lib_args + {
  'name_prefix': '',
}

default_bin_args = default_target_args + {
}

if host_machine.system() == 'windows'
  # nothing to do
else
  if host_machine.system() == 'darwin'
    rpath_var = '@loader_path'
  else
    rpath_var = '$ORIGIN'
  endif

  # PG binaries might need to link to libpq, use relative path to reference
  bin_to_lib = run_command(relpath,
    get_option('bindir'), get_option('libdir'), check: true).stdout().strip()
  default_bin_args += {'install_rpath':  rpath_var / bin_to_lib}

  # PG extensions might need to link to libpq, use relative path to reference
  # (often just .)
  mod_to_lib = run_command(relpath,
    get_option('libdir'), get_option('libdir'), check: true).stdout().strip()
  default_mod_args += {'install_rpath': rpath_var}
endif


###
### windows resources related stuff
###

rc_cdata = configuration_data()
rc_cdata.set_quoted('ICO', meson.source_root() / 'src' / 'port' / 'win32.ico')

rc_lib_cdata = rc_cdata
rc_lib_cdata.set('VFT_TYPE', 'VFT_DLL')

rc_bin_cdata = rc_cdata
rc_bin_cdata.set('VFT_TYPE', 'VFT_APP')

win32ver_rc_in = files('src/port/win32ver.rc.in')


# First visit src/include - all targets creating headers are defined
# within. That makes it easy to add the necessary dependencies for the
# subsequent build steps.

generated_headers = []
generated_backend_headers = []

postgres_inc = [include_directories('src/include')]

if host_machine.system() == 'windows'
  postgres_inc += include_directories('src/include/port/win32')

  if cc.get_id() == 'msvc'
    postgres_inc += include_directories('src/include/port/win32_msvc')
  endif
endif

subdir('src/include')


# Then through src/port and src/common, as most other things depend on them

frontend_port_code = declare_dependency(
  compile_args: ['-DFRONTEND'],
  include_directories: [postgres_inc],
  sources: [errcodes],
  dependencies: os_deps,
)

backend_port_code = declare_dependency(
  compile_args: ['-DBUILDING_DLL'],
  include_directories: [postgres_inc],
  sources: [errcodes],
  dependencies: os_deps,
)

subdir('src/port')

frontend_common_code = declare_dependency(
  compile_args: ['-DFRONTEND'],
  include_directories: [postgres_inc],
  sources: generated_headers,
  dependencies: os_deps,
)

backend_common_code = declare_dependency(
  compile_args: ['-DBUILDING_DLL'],
  include_directories: [postgres_inc],
  sources: generated_headers,
)

subdir('src/common')

frontend_shlib_code = declare_dependency(
  compile_args: ['-DFRONTEND'],
  include_directories: [postgres_inc],
  link_with: [pgport_shlib, common_shlib],
  sources: generated_headers,
  dependencies: os_deps,
)

subdir('src/interfaces/libpq')
subdir('src/fe_utils')

frontend_code = declare_dependency(
  compile_args: ['-DFRONTEND'],
  include_directories: [postgres_inc],
  link_with: [pgport_static, common_static, fe_utils],
  sources: generated_headers,
  dependencies: os_deps,
)

backend_code = declare_dependency(
  compile_args: ['-DBUILDING_DLL'],
  include_directories: [postgres_inc],
  link_with: [],
  sources: generated_headers + generated_backend_headers,
  dependencies: [os_deps, ssl, lz4, icu, icu_i18n, ldap, gssapi, libxml, systemd],
)

# Note there's intentionally no dependency on pgport/common here - we want the
# symbols from the main binary for extension modules, rather than the
# extension linking separately to pgport/common.
backend_mod_code = declare_dependency(
  compile_args: [],
  include_directories: [postgres_inc],
  link_with: [],
  sources: generated_headers + generated_backend_headers,
  dependencies: [os_deps, ssl, lz4, icu, icu_i18n, ldap, gssapi, libxml, systemd],
)

# Then through the main sources. That way contrib can have dependencies on
# main sources. Note that this explicitly doesn't enter src/test, right now a
# few regression tests depend on contrib files.

subdir('src')

subdir('contrib')

subdir('src/test')

subdir('doc/src/sgml')


if host_machine.system() == 'darwin'
  meson.add_install_script('src/tools/relativize_shared_library_references')
endif



###############################################################
# Test prep
###############################################################

# The determination of where a DESTDIR install points to is ugly, it's somewhat hard
# to combine two absolute paths portably...

prefix = get_option('prefix')

test_prefix = prefix

if fs.is_absolute(get_option('prefix'))
  if host_machine.system() == 'windows'
    if prefix.split(':\\').length() == 1
        # just a drive
        test_prefix = ''
    else
        test_prefix = prefix.split(':\\')[1]
    endif
  else
    test_prefix = prefix.substring(1)
  endif
endif

# DESTDIR for the installation used to run tests in
test_install_destdir = meson.build_root() / 'tmp_install/'
# DESTDIR + prefix appropriately munged
test_install_location = test_install_destdir / test_prefix


test('tmp_install',
    meson_bin, args: meson_args + ['install', '--quiet', '--only-changed', '--no-rebuild'],
    env: {'DESTDIR':test_install_destdir},
    priority: 100,
    is_parallel: false,
    suite: ['setup'])

test_result_dir = meson.build_root() / 'testrun'


# XXX: pg_regress doesn't assign unique ports on windows. To avoid the
# inevitable conflicts from running tests in parallel, hackishly assign
# different ports for different tests.

testport=40000

test_env = environment()

test_env.prepend('PATH', test_install_location / get_option('bindir'))
test_env.set('PG_REGRESS', meson.build_root() / 'src/test/regress/pg_regress')
test_env.set('REGRESS_SHLIB', regress_module.full_path())



###############################################################
# Test Generation
###############################################################

# Define all 'pg_regress' style tests
foreach t : regress_tests
  test_command = [
    pg_regress,
    '--temp-instance', test_result_dir / t['name'] / 'pg_regress' / 'tmp_check',
    '--inputdir', t['sd'],
    '--outputdir', test_result_dir / t['name'] / 'pg_regress',
    '--bindir', '',
    '--dlpath', t['bd'],
    '--max-concurrent-tests=20',
    '--port=@0@'.format(testport),
  ]

  if t.has_key('regress_args')
     test_command += t['regress_args']
  endif

  if t.has_key('schedule')
     test_command += ['--schedule', t['schedule'],]
  else
     test_command += t['sql']
  endif

  test_kwargs = {
    'suite': ['pg_regress', t['name']],
    'priority': 10,
    'timeout': 300,
    'depends': test_deps + t.get('deps', []),
    'env': test_env,
    'workdir': t['sd'],
    'args': [
      meson.build_root(),
      t['bd'],
      t['name'],
      'pg_regress',
      test_command,
    ]
  }

  # Allow test definition to override arguments
  if t.has_key('test_kwargs')
     test_kwargs += t['test_kwargs']
  endif

  test(t['name'] / 'pg_regress',
    testwrap,
    kwargs: test_kwargs,
  )

  testport = testport + 1
endforeach


# Define all 'isolationtester' style tests
foreach t : isolation_tests
  test_command = [
    pg_isolation_regress,
    '--temp-instance', test_result_dir / t['name'] / 'isolation' / 'tmp_check',
    '--inputdir', t['sd'],
    '--outputdir', test_result_dir / t['name'] / 'isolation',
    '--bindir', '',
    '--dlpath', t['bd'],
    '--max-concurrent-tests=20',
    '--port=@0@'.format(testport),
  ]

  if t.has_key('regress_args')
     test_command += t['regress_args']
  endif

  if t.has_key('schedule')
     test_command += ['--schedule', t['schedule'],]
  else
     test_command += t['specs']
  endif

  test_kwargs = {
    'suite': ['isolation', t['name']],
    'priority': 20,
    'timeout': 300,
    'depends': test_deps + t.get('deps', []),
    'workdir': t['sd'],
    'env': test_env,
    'args': [
      meson.build_root(),
      t['bd'],
      t['name'],
      'isolation',
      test_command,
    ]
  }

  # Allow test definition to override arguments
  if t.has_key('test_kwargs')
     test_kwargs += t['test_kwargs']
  endif

  test(t['name'] / 'isolation',
    testwrap,
    kwargs: test_kwargs,
  )

  testport = testport + 1
endforeach


# Define all 'tap' style tests
# FIXME: dependencies for each test
foreach t : tap_tests
  env = test_env

  foreach name, value : t.get('env', {})
    if name == 'PATH'
      # FIXME: manually setting PATH again, because repeated prepend didn't work
      # before meson 0.58.
      env.prepend('PATH', value, test_install_location / get_option('bindir'))
    else
      env.set(name, value)
    endif
  endforeach

  foreach onetap : t['tests']
    test(t['name'] / onetap,
      testwrap,
      workdir: t['sd'],
      args: [
        meson.build_root(),
        t['bd'],
        t['name'],
        onetap,
        'perl',
        '-I', meson.source_root() / 'src/test/perl',
        '-I', t['sd'],
        t['sd'] / onetap
      ],
      protocol: 'tap',
      suite: ['tap', t['name']],
      env: env,
      depends: test_deps + t.get('deps', []),
      timeout: 300,
      )
  endforeach
endforeach



###############################################################
# Pseudo targets
###############################################################

alias_target('backend', backend_targets)



###############################################################
# The End, The End, My Friend
###############################################################

if meson.version().version_compare('>=0.57')

  summary({
    'Data Block Size' : cdata.get('BLCKSZ'),
    'WAL Block Size' : cdata.get('XLOG_BLCKSZ')
    }, section: 'Data Layout'
  )

  summary(
    {
      'host system' : '@0@ @1@'.format(host_machine.system(), host_machine.cpu_family()),
      'build system' : '@0@ @1@'.format(build_machine.system(), build_machine.cpu_family()),
    },
    section: 'System'
  )

  summary(
    {
      'linker': '@0@'.format(cc.get_linker_id()),
      'C compiler': '@0@ @1@'.format(cc.get_id(), cc.version()),
    },
    section: 'Compiler'
  )

  if llvm.found()
    summary(
      {
        'C++ compiler': '@0@ @1@'.format(cpp.get_id(), cpp.version())
      },
      section: 'Compiler')
  endif

  summary(
    {
      'bison' : '@0@ @1@'.format(bison.full_path(), bison_version),
    },
    section: 'Programs'
  )

  summary(
    {
      'GSS': gssapi,
      'LDAP': ldap,
      'LLVM': llvm,
      'icu': icu,
      'libxml': libxml,
      'libxslt': libxslt,
      'lz4': lz4,
      'perl': perl_dep,
      'python3': python3,
      'readline': readline,
      'selinux': selinux,
      'ssl': ssl,
      'systemd': systemd,
      'uuid': uuid,
      'zlib': zlib,
    },
    section: 'External Libraries'
  )

endif
